# Exploring Remix

To start the app run `npm run dev`.

I've seen Remix mentioned a few times now, which is usually my signal to spend a little bit of time playing around with it to see what it's all about. I followed the [15 Minute Introductory Tutorial](https://remix.run/docs/en/v1/tutorials/blog) and had a great time with it. 

For context, my experience of web development up to this point is mostly React frontend development talking to a Django Python API. The appeal (and selling point) of Remix is the merging of those two pieces into one framework. I was curious what the difference would be between the traditional Django serverside rendered applications, after having spent some time with Remix my current opinion is that it's no different, it's just a lot more "Reacty" than Django templating which makes frontend development a lot easier and more pleasant to work with.

# Thoughts (In no particular order)
 - I like the JSX and that it has the look and feel of simple HTML. Templating in JSX is very familiar to me due to React, and it felt natural building out FE pages.
 - I really like the BE being right next to the FE. I am tired of opening up the Django BE API in another window, making changes, verifying the output is as expected, then making changes to a React FE component to fetch that data, display it etc. BE/FE communications can get very chatty when data is being submitted, particularly if data validation is being done on the backend and must be communicated back to the frontend. With Remix I was making a change at the top of the file, then simply scrolling down to edit the FE. It's very clear how the code is separated out, the function Post() for example is the part that renders the UI, much like in React. The loader() and action() functions define the BE behaviour. I still need to get my head around exactly which bits of code run on the FE, and which on the BE, but in my mind the Posts() function was for FE and the other two were for BE logic, clearly delineating the two and making it easy to think about information flow between them. 
 - One red flag that occured to me is that the example tutorial is for a basic CRUD application loading and displaying blog posts. (As is every single web development tutorial out there). I suspect this was just the best example to show off the most features as quickly as possible, but it made me wonder how suitable Remix is for developing beyond such applications. At work, we have a very complicated frontend that carries out a lot of the application functionality within the browser itself, it's not just fetching and sending data to the BE. I suspect Remix can handle this but would need to spend more time with it. I feel a project coming on...
 - I thought the nesting was very cool, and once I'd wrapped my head around it, quite logical. I could see how everything hangs off of the URL, so a posts page might display some common post page UI, and then as nested components are loaded, the URL expands to accomodate them. This is exactly how nested routes work in REST APIs. The nice think about remix was how the directory structure of the source files mirrors it, so it's fairly obvious where each component lives and how they fit into the parent component (using the <Outlet />) tag. And given that each component (is that the right term for Remix?) handles it's own BE as well, it feels like I'm bringing the concept of components into the BE world as well. It wasn't totally clear to me how detail components were being rendered and how it knew what files to load, but that just means I need to spend a bit more time with it.
 - I liked the module concept which defines all actual I/O with the database (or any other API). It felt a bit like redux, where you pull all your state out into a separate place in the code and define getters/setters etc that your components use. Whereas Redux state is living in browser memory, the remix module is executing on the server. The code organisation was familiar, it defined getters for loading and returning data, and setters, both which are called from within the components (and importantly, from any component if needed).
 - Although I deployed onto the default Remix Server as suggested in the demo (and ran locally), deployment options suggested I could run off of AWS Lambda which is a very cool idea. 
 - They make a big fuss of HTML Forms being just that, HTML Forms, no need for onSubmit or onClick etc. Personally I don't see a problem with those functions, I use them all the time and they're fine, but it's interesting that it can all work without any JS running in the browser.
 - I loved the back and forth between FE/BE in the form submission example, I think it showed Remix's true colours. You define a form in the FE and set the method to POST, then in the same source file you define an action function that receives a request parameter with the form data on it. It felt like I was just calling a function in the same file, the fact that one would execute on the clients machine and the other in the server was completely abstracted away, very cool. It got even better when I realised that I could return errors from the action function and they would "reappear" in the FE under a hook that could be used to show different bits of UI depending on what the errors were. Magical.
 - The action function itself reminded me a lot of Django's FormClass POST behaviour. Receive form data on a POST request, validate it, return any errors, if not, save to database. 
 - Error handling wasn't covered in the introductory tutorial but the main website talks a bit about it, now that I understand what Remix is doing, I can see how the nested and separated components each define what gets shown when they encounter an error, meaning that error boundaries are natively supported by Remix.  
 - Lastly, they make a big fuss of the lack of loading spinners, which I guess is a good thing. Personally you can get rid of loading spinners by being smarter about where you fetch the data in the FE, but I appreciate that because Remix is sending the HTML page in one go that it appears at once and feels snappy. That being said, I'm curious as to what happens when Remix has to do a lot of work to build the page? Is it just blank on the FE? That's the benefit of spinners, the fast parts of the UI can load whilst slower parts resolve, they're not all bad, and they're not all caused by BE/FE split, something you have large amounts of data to fetch for display. Would be interesting to see how Remix behaves under those conditions.

